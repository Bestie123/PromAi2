<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>PromAi PKM - –í–∞—Ä–∏–∞–Ω—Ç—ã –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–∏–∞–≥—Ä–∞–º–º—ã</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0d1117; color: #c9d1d9; overflow: hidden;
        }
        #canvas { 
            width: 25000px; height: 15000px; position: relative; 
            background: radial-gradient(circle at 50% 50%, #161b22 0%, #0d1117 100%);
            transform-origin: 0 0;
        }
        #viewport { 
            width: 100vw; height: 100vh; overflow: hidden; position: relative;
            cursor: grab; background: #0d1117;
        }
        #viewport.dragging { cursor: grabbing; }
        
        .node {
            position: absolute; background: #21262d; border: 2px solid #30363d;
            border-radius: 12px; padding: 14px; min-width: 260px; max-width: 300px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4); transition: all 0.3s ease;
        }
        .node:hover { transform: scale(1.05); box-shadow: 0 12px 48px rgba(0,0,0,0.6); z-index: 100; }
        /* –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –Ω–æ–¥ –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏/–∫–ª–∏–∫–µ –Ω–∞ —Å—Ç—Ä–µ–ª–∫—É */
        .node.arrow-highlighted { 
            transform: scale(1.08); 
            box-shadow: 0 0 20px rgba(88, 166, 255, 0.6); 
            z-index: 101;
            animation: pulse 1.5s ease-in-out infinite;
        }
        /* –ê–Ω–∏–º–∞—Ü–∏—è –ø—É–ª—å—Å–∞—Ü–∏–∏ –¥–ª—è –≤—ã–¥–µ–ª–µ–Ω–Ω—ã—Ö –Ω–æ–¥ */
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 20px rgba(88, 166, 255, 0.6); }
            50% { box-shadow: 0 0 30px rgba(88, 166, 255, 0.9); }
        }
        
        .question { 
            border-color: #58a6ff; border-width: 3px;
            background: linear-gradient(135deg, #1b2332 0%, #21262d 100%);
        }
        .critical { 
            border-color: #f85149; border-width: 2px;
            background: linear-gradient(135deg, #2d1b1f 0%, #21262d 100%);
        }
        .parallel { 
            border-color: #f79009; border-width: 2px;
            background: linear-gradient(135deg, #2d2419 0%, #21262d 100%);
        }
        .rejected { 
            border-color: #8b949e; border-width: 2px;
            background: linear-gradient(135deg, #2d2d2d 0%, #21262d 100%); 
            opacity: 0.5;
        }
        
        .badge {
            display: inline-block; padding: 3px 7px; border-radius: 5px; font-size: 10px;
            font-weight: bold; margin-bottom: 6px; margin-right: 3px;
        }
        .badge.question { background: #58a6ff; color: #fff; }
        .badge.critical { background: #f85149; color: #fff; }
        .badge.parallel { background: #f79009; color: #fff; }
        .badge.rejected { background: #8b949e; color: #fff; }
        
        .node h3 { font-size: 13px; margin-bottom: 6px; color: #f0f6fc; font-weight: 600; }
        .node p { font-size: 11px; line-height: 1.3; margin-bottom: 5px; color: #8b949e; }
        .node .info { font-size: 10px; color: #6e7681; margin-top: 4px; }
        
        .connection {
            position: absolute; height: 2px; transform-origin: left center; z-index: -1;
            cursor: pointer; pointer-events: auto; transition: all 0.2s;
        }
        .connection.q-to-answer { background: #58a6ff; }
        .connection.answer-to-q { background: #f79009; height: 3px; }
        .connection:hover, .connection.highlighted { height: 4px; filter: brightness(1.5); z-index: 10; }
        .connection.locked { height: 5px; filter: brightness(1.8) drop-shadow(0 0 8px currentColor); z-index: 20; }
        
        .arrow {
            position: absolute; width: 0; height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-top: 8px solid #58a6ff;
            right: -8px; top: -3px; transition: all 0.2s;
        }
        .connection.answer-to-q .arrow { border-top-color: #f79009; }
        .connection:hover .arrow, .connection.highlighted .arrow { 
            border-left: 7px solid transparent;
            border-right: 7px solid transparent;
            border-top: 12px solid #58a6ff;
            top: -5px;
        }
        .connection.answer-to-q:hover .arrow, .connection.answer-to-q.highlighted .arrow { border-top-color: #f79009; }
        .connection.locked .arrow {
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-top: 14px solid #58a6ff;
            top: -6px;
        }
        .connection.answer-to-q.locked .arrow { border-top-color: #f79009; }
        
        .controls {
            position: fixed; top: 20px; left: 20px; z-index: 1000;
            background: rgba(33, 38, 45, 0.95); padding: 14px; border-radius: 8px;
            border: 1px solid #30363d; max-width: 300px;
        }
        .controls button {
            background: #238636; color: #fff; border: none; padding: 7px 11px;
            border-radius: 6px; margin-right: 6px; margin-bottom: 6px; cursor: pointer; font-size: 11px;
        }
        .controls button:hover { background: #2ea043; }
        .controls button.active { background: #1f6feb; }
        .controls .legend { margin-top: 10px; font-size: 10px; color: #8b949e; }
        .controls h4 { font-size: 12px; margin-bottom: 8px; color: #f0f6fc; }
        
        .zoom-info {
            position: fixed; bottom: 20px; right: 20px; z-index: 1000;
            background: rgba(33, 38, 45, 0.9); padding: 7px 11px; border-radius: 6px;
            border: 1px solid #30363d; font-size: 11px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <h4>–í–∞—Ä–∏–∞–Ω—Ç—ã –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è:</h4>
        <button onclick="setLayout('horizontal')" id="btn-horizontal" class="active">–ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–π</button>
        <button onclick="setLayout('vertical')" id="btn-vertical">–í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π</button>
        <button onclick="setLayout('compact')" id="btn-compact">–ö–æ–º–ø–∞–∫—Ç–Ω—ã–π</button>
        <button onclick="setLayout('tree')" id="btn-tree">–î—Ä–µ–≤–æ–≤–∏–¥–Ω—ã–π</button>
        
        <div style="margin: 10px 0; border-top: 1px solid #30363d; padding-top: 10px;">
            <button onclick="resetView()">–°–±—Ä–æ—Å</button>
            <button onclick="centerView()">–¶–µ–Ω—Ç—Ä</button>
        </div>
        
        <div class="legend">
            üîµ –í–æ–ø—Ä–æ—Å ‚Üí üî¥ –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π / üü† –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–π ‚Üí üîµ –°–ª–µ–¥. –≤–æ–ø—Ä–æ—Å
        </div>
    </div>
    
    <div class="zoom-info">
        –ó—É–º: <span id="zoomLevel">100%</span> | Layout: <span id="layoutName">–ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–π</span>
    </div>
    
    <div id="viewport">
        <div id="canvas"></div>
    </div>

    <script>
        let scale = 0.12;
        let translateX = 100;
        let translateY = 100;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let currentLayout = 'horizontal';
        let planData = null;

        fetch('./development_plan.json')
            .then(response => response.json())
            .then(data => {
                planData = data;
                initCanvas(currentLayout);
                updateTransform();
            });

        function setLayout(layout) {
            currentLayout = layout;
            document.querySelectorAll('.controls button').forEach(b => b.classList.remove('active'));
            document.getElementById(`btn-${layout}`).classList.add('active');
            
            const names = {
                horizontal: '–ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–π',
                vertical: '–í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π',
                compact: '–ö–æ–º–ø–∞–∫—Ç–Ω—ã–π',
                tree: '–î—Ä–µ–≤–æ–≤–∏–¥–Ω—ã–π'
            };
            document.getElementById('layoutName').textContent = names[layout];
            
            if (planData) {
                initCanvas(layout);
                resetView();
            }
        }

        function initCanvas(layout) {
            const canvas = document.getElementById('canvas');
            canvas.innerHTML = '';
            const nodeMap = {};
            
            const critical = planData.levels[0].tracks.critical.criteria;
            const parallel = planData.levels[0].tracks.parallel.criteria;
            const allCriteria = [...critical, ...parallel];
            
            switch(layout) {
                case 'horizontal':
                    layoutHorizontal(canvas, allCriteria, nodeMap);
                    break;
                case 'vertical':
                    layoutVertical(canvas, allCriteria, nodeMap);
                    break;
                case 'compact':
                    layoutCompact(canvas, allCriteria, nodeMap);
                    break;
                case 'tree':
                    layoutTree(canvas, allCriteria, nodeMap);
                    break;
            }
            
            // –û—Ç–ª–æ–∂–µ–Ω–Ω–∞—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∞ —Å–≤—è–∑–µ–π answer-to-q
            setTimeout(() => {
                allCriteria.forEach(criterion => {
                    if (criterion.blocks && criterion.blocks.length > 0) {
                        const selectedId = `${criterion.id}_selected`;
                        criterion.blocks.forEach(blockedQId => {
                            const nextQId = `q${blockedQId.replace('q', '')}`;
                            if (nodeMap[selectedId] && nodeMap[nextQId]) {
                                canvas.appendChild(createConnection(
                                    nodeMap[selectedId],
                                    nodeMap[nextQId],
                                    'answer-to-q'
                                ));
                            }
                        });
                    }
                    
                    // –°—Ç—Ä–µ–ª–∫–∏ –æ—Ç –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π –∫ —Ç–µ–∫—É—â–µ–º—É –≤–æ–ø—Ä–æ—Å—É
                    if (criterion.requires && criterion.requires.length > 0) {
                        const currentQId = `q${criterion.id}`;
                        criterion.requires.forEach(reqId => {
                            const reqNum = planData.nodeMapping ? Object.keys(planData.nodeMapping).find(k => planData.nodeMapping[k].selected === reqId) : null;
                            if (reqNum) {
                                const reqSelectedId = `${reqNum}_selected`;
                                if (nodeMap[reqSelectedId] && nodeMap[currentQId]) {
                                    canvas.appendChild(createConnection(
                                        nodeMap[reqSelectedId],
                                        nodeMap[currentQId],
                                        'answer-to-q'
                                    ));
                                }
                            }
                        });
                    }
                });
            }, 100);
        }

        // Layout 1: –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–π (–≤–æ–ø—Ä–æ—Å —Å–ª–µ–≤–∞, –æ—Ç–≤–µ—Ç—ã —Å–ø—Ä–∞–≤–∞)
        function layoutHorizontal(canvas, criteria, nodeMap) {
            let yOffset = 300;
            criteria.forEach(criterion => {
                const questionId = `q${criterion.id}`;
                const xBase = 500;
                
                const qNode = createQuestionNode(criterion);
                qNode.style.left = xBase + 'px';
                qNode.style.top = yOffset + 'px';
                canvas.appendChild(qNode);
                nodeMap[questionId] = { x: xBase, y: yOffset };
                
                const selectedNode = createAnswerNode(criterion, criterion.solution, criterion.priority);
                selectedNode.style.left = (xBase + 600) + 'px';
                selectedNode.style.top = yOffset + 'px';
                canvas.appendChild(selectedNode);
                const selectedId = `${criterion.id}_selected`;
                nodeMap[selectedId] = { x: xBase + 600, y: yOffset };
                
                canvas.appendChild(createConnection(nodeMap[questionId], nodeMap[selectedId], 'q-to-answer'));
                
                if (criterion.alternatives && criterion.alternatives.length > 0) {
                    criterion.alternatives.forEach((alt, altIdx) => {
                        const altNode = createAnswerNode(criterion, alt, 'rejected');
                        const altY = yOffset + (altIdx + 1) * 200;
                        altNode.style.left = (xBase + 600) + 'px';
                        altNode.style.top = altY + 'px';
                        canvas.appendChild(altNode);
                        canvas.appendChild(createConnection(nodeMap[questionId], { x: xBase + 600, y: altY }, 'q-to-answer'));
                    });
                }
                
                yOffset += 400 + (criterion.alternatives ? criterion.alternatives.length * 200 : 0);
            });
        }

        // Layout 2: –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π (–≤–æ–ø—Ä–æ—Å —Å–≤–µ—Ä—Ö—É, –æ—Ç–≤–µ—Ç—ã —Å–Ω–∏–∑—É)
        function layoutVertical(canvas, criteria, nodeMap) {
            let xOffset = 500;
            criteria.forEach(criterion => {
                const questionId = `q${criterion.id}`;
                const yBase = 300;
                
                const qNode = createQuestionNode(criterion);
                qNode.style.left = xOffset + 'px';
                qNode.style.top = yBase + 'px';
                canvas.appendChild(qNode);
                nodeMap[questionId] = { x: xOffset, y: yBase };
                
                const selectedNode = createAnswerNode(criterion, criterion.solution, criterion.priority);
                selectedNode.style.left = xOffset + 'px';
                selectedNode.style.top = (yBase + 250) + 'px';
                canvas.appendChild(selectedNode);
                const selectedId = `${criterion.id}_selected`;
                nodeMap[selectedId] = { x: xOffset, y: yBase + 250 };
                
                canvas.appendChild(createConnection(nodeMap[questionId], nodeMap[selectedId], 'q-to-answer'));
                
                if (criterion.alternatives && criterion.alternatives.length > 0) {
                    criterion.alternatives.forEach((alt, altIdx) => {
                        const altNode = createAnswerNode(criterion, alt, 'rejected');
                        const altX = xOffset + (altIdx + 1) * 350;
                        altNode.style.left = altX + 'px';
                        altNode.style.top = (yBase + 250) + 'px';
                        canvas.appendChild(altNode);
                        canvas.appendChild(createConnection(nodeMap[questionId], { x: altX, y: yBase + 250 }, 'q-to-answer'));
                    });
                }
                
                xOffset += 700 + (criterion.alternatives ? criterion.alternatives.length * 350 : 0);
            });
        }

        // Layout 3: –ö–æ–º–ø–∞–∫—Ç–Ω—ã–π (–º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ –æ—Ç—Å—Ç—É–ø—ã)
        function layoutCompact(canvas, criteria, nodeMap) {
            let yOffset = 200;
            criteria.forEach(criterion => {
                const questionId = `q${criterion.id}`;
                const xBase = 400;
                
                const qNode = createQuestionNode(criterion);
                qNode.style.left = xBase + 'px';
                qNode.style.top = yOffset + 'px';
                canvas.appendChild(qNode);
                nodeMap[questionId] = { x: xBase, y: yOffset };
                
                const selectedNode = createAnswerNode(criterion, criterion.solution, criterion.priority);
                selectedNode.style.left = (xBase + 400) + 'px';
                selectedNode.style.top = yOffset + 'px';
                canvas.appendChild(selectedNode);
                const selectedId = `${criterion.id}_selected`;
                nodeMap[selectedId] = { x: xBase + 400, y: yOffset };
                
                canvas.appendChild(createConnection(nodeMap[questionId], nodeMap[selectedId], 'q-to-answer'));
                
                if (criterion.alternatives && criterion.alternatives.length > 0) {
                    criterion.alternatives.forEach((alt, altIdx) => {
                        const altNode = createAnswerNode(criterion, alt, 'rejected');
                        const altY = yOffset + (altIdx + 1) * 120;
                        altNode.style.left = (xBase + 400) + 'px';
                        altNode.style.top = altY + 'px';
                        canvas.appendChild(altNode);
                        canvas.appendChild(createConnection(nodeMap[questionId], { x: xBase + 400, y: altY }, 'q-to-answer'));
                    });
                }
                
                yOffset += 250 + (criterion.alternatives ? criterion.alternatives.length * 120 : 0);
            });
        }

        // Layout 4: –î—Ä–µ–≤–æ–≤–∏–¥–Ω—ã–π (–≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –ø–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞–º)
        function layoutTree(canvas, criteria, nodeMap) {
            const critical = criteria.filter(c => c.priority === 'critical');
            const parallel = criteria.filter(c => c.priority === 'parallel');
            
            let yOffset = 300;
            
            // –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ —Å–ª–µ–≤–∞
            critical.forEach(criterion => {
                const questionId = `q${criterion.id}`;
                const xBase = 500;
                
                const qNode = createQuestionNode(criterion);
                qNode.style.left = xBase + 'px';
                qNode.style.top = yOffset + 'px';
                canvas.appendChild(qNode);
                nodeMap[questionId] = { x: xBase, y: yOffset };
                
                const selectedNode = createAnswerNode(criterion, criterion.solution, criterion.priority);
                selectedNode.style.left = (xBase + 500) + 'px';
                selectedNode.style.top = yOffset + 'px';
                canvas.appendChild(selectedNode);
                const selectedId = `${criterion.id}_selected`;
                nodeMap[selectedId] = { x: xBase + 500, y: yOffset };
                
                canvas.appendChild(createConnection(nodeMap[questionId], nodeMap[selectedId], 'q-to-answer'));
                
                yOffset += 300;
            });
            
            // –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–µ —Å–ø—Ä–∞–≤–∞
            yOffset = 300;
            parallel.forEach(criterion => {
                const questionId = `q${criterion.id}`;
                const xBase = 2000;
                
                const qNode = createQuestionNode(criterion);
                qNode.style.left = xBase + 'px';
                qNode.style.top = yOffset + 'px';
                canvas.appendChild(qNode);
                nodeMap[questionId] = { x: xBase, y: yOffset };
                
                const selectedNode = createAnswerNode(criterion, criterion.solution, criterion.priority);
                selectedNode.style.left = (xBase + 500) + 'px';
                selectedNode.style.top = yOffset + 'px';
                canvas.appendChild(selectedNode);
                const selectedId = `${criterion.id}_selected`;
                nodeMap[selectedId] = { x: xBase + 500, y: yOffset };
                
                canvas.appendChild(createConnection(nodeMap[questionId], nodeMap[selectedId], 'q-to-answer'));
                
                yOffset += 300;
            });
        }

        function createQuestionNode(criterion) {
            const div = document.createElement('div');
            div.className = 'node question';
            
            const reqNums = criterion.requires && criterion.requires.length > 0 && planData && planData.nodeMapping
                ? criterion.requires.map(r => Object.keys(planData.nodeMapping).find(k => planData.nodeMapping[k].selected === r)).filter(Boolean)
                : [];
            const reqText = reqNums.length > 0 ? `üìã –¢—Ä–µ–±—É–µ—Ç: ‚Ññ${reqNums.join(', ‚Ññ')}` : (criterion.requires && criterion.requires.length > 0 ? `üìã –¢—Ä–µ–±—É–µ—Ç: ${criterion.requires.join(', ')}` : 'üìã –ù–µ —Ç—Ä–µ–±—É–µ—Ç –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π');
            const blockText = criterion.blocks && criterion.blocks.length > 0 
                ? `üö´ –ë–ª–æ–∫–∏—Ä—É–µ—Ç: ‚Ññ${criterion.blocks.map(b => b.replace('q', '')).join(', ‚Ññ')}` : 'üö´ –ù–∏—á–µ–≥–æ –Ω–µ –±–ª–æ–∫–∏—Ä—É–µ—Ç';
            
            div.innerHTML = `
                <div class="badge question">‚ùì –í–û–ü–†–û–° ‚Ññ${criterion.id}</div>
                <h3>${criterion.question}</h3>
                <p>${criterion.title}</p>
                <div class="info">Week ${criterion.week || '?'} | ${criterion.time}</div>
                <div class="info">${reqText}</div>
                <div class="info">${blockText}</div>
            `;
            return div;
        }

        function createAnswerNode(criterion, solution, priority) {
            const div = document.createElement('div');
            div.className = `node ${priority}`;
            const badgeText = priority === 'critical' ? 'üî¥ –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô ‚Ññ' + criterion.id :
                             priority === 'parallel' ? 'üü† –ü–ê–†–ê–õ–õ–ï–õ–¨–ù–´–ô ‚Ññ' + criterion.id : '‚ùå –û–¢–ö–õ–û–ù–ï–ù–û ‚Ññ' + criterion.id;
            
            const reqNums = criterion.requires && criterion.requires.length > 0 && planData && planData.nodeMapping
                ? criterion.requires.map(r => Object.keys(planData.nodeMapping).find(k => planData.nodeMapping[k].selected === r)).filter(Boolean)
                : [];
            const reqText = reqNums.length > 0 ? `üìã –¢—Ä–µ–±—É–µ—Ç: ‚Ññ${reqNums.join(', ‚Ññ')}` : (criterion.requires && criterion.requires.length > 0 ? `üìã –¢—Ä–µ–±—É–µ—Ç: ${criterion.requires.join(', ')}` : 'üìã –ù–µ —Ç—Ä–µ–±—É–µ—Ç –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π');
            const blockText = criterion.blocks && criterion.blocks.length > 0 
                ? `üö´ –ë–ª–æ–∫–∏—Ä—É–µ—Ç: ‚Ññ${criterion.blocks.map(b => b.replace('q', '')).join(', ‚Ññ')}` : 'üö´ –ù–∏—á–µ–≥–æ –Ω–µ –±–ª–æ–∫–∏—Ä—É–µ—Ç';
            
            const prosText = solution.pros && solution.pros.length > 0
                ? `‚úÖ –ü–ª—é—Å—ã: ${solution.pros.join('; ')}` : '';
            const consText = solution.cons && solution.cons.length > 0
                ? `‚ùå –ú–∏–Ω—É—Å—ã: ${solution.cons.join('; ')}` : '';
            
            const solutionId = planData.nodeMapping && planData.nodeMapping[criterion.id] ? planData.nodeMapping[criterion.id].selected : null;
            const compatText = getCompatibility(solutionId, criterion);
            
            div.innerHTML = `
                <div class="badge ${priority}">${badgeText}</div>
                <h3>${solution.name}</h3>
                <p>${solution.description}</p>
                <div class="info">${reqText}</div>
                <div class="info">${blockText}</div>
                <div class="info" style="color: #3fb950;">${prosText}</div>
                <div class="info" style="color: #f85149;">${consText}</div>
                <div class="info" style="color: #a371f7;">${compatText}</div>
            `;
            return div;
        }
        
        function getCompatibility(solutionId, criterion) {
            if (!planData.compatibility || !solutionId || !criterion.alternatives) return '';
            
            const altIds = planData.nodeMapping && planData.nodeMapping[criterion.id] 
                ? planData.nodeMapping[criterion.id].alternatives || [] 
                : [];
            
            const results = [];
            altIds.forEach((altId, idx) => {
                const key1 = `${solutionId},${altId}`;
                const key2 = `${altId},${solutionId}`;
                const compat = planData.compatibility[key1] || planData.compatibility[key2];
                if (compat && criterion.alternatives[idx]) {
                    results.push(`${criterion.alternatives[idx].name}: ${compat}`);
                }
            });
            
            return results.length > 0 ? `üîÄ –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å: ${results.join('; ')}` : '';
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ç—Ä–µ–ª–∫–∏ –º–µ–∂–¥—É –Ω–æ–¥–∞–º–∏ —Å –ø–æ–¥—Å–≤–µ—Ç–∫–æ–π —Å–≤—è–∑–∞–Ω–Ω—ã—Ö –Ω–æ–¥
        function createConnection(from, to, type) {
            const line = document.createElement('div');
            line.className = `connection ${type}`;
            
            // –ê–≤—Ç–æ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –æ–ø—Ç–∏–º–∞–ª—å–Ω—ã—Ö —Ç–æ—á–µ–∫ –≤—Ö–æ–¥–∞/–≤—ã—Ö–æ–¥–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤–∑–∞–∏–º–Ω–æ–≥–æ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è –Ω–æ–¥
            const nodeWidth = 260;
            const nodeHeight = 100;
            
            // –¶–µ–Ω—Ç—Ä—ã –Ω–æ–¥
            const fromCenterX = from.x + nodeWidth / 2;
            const fromCenterY = from.y + nodeHeight / 2;
            const toCenterX = to.x + nodeWidth / 2;
            const toCenterY = to.y + nodeHeight / 2;
            
            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —É–≥–æ–ª –º–µ–∂–¥—É –Ω–æ–¥–∞–º–∏
            const connectionAngle = Math.atan2(toCenterY - fromCenterY, toCenterX - fromCenterX);
            const angleDeg = connectionAngle * 180 / Math.PI;
            
            let fromX, fromY, toX, toY;
            
            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–æ—á–∫—É –≤—ã—Ö–æ–¥–∞ –∏–∑ –∏—Å—Ö–æ–¥–Ω–æ–π –Ω–æ–¥—ã
            if (angleDeg >= -45 && angleDeg < 45) {
                // –í—ã—Ö–æ–¥ —Å–ø—Ä–∞–≤–∞
                fromX = from.x + nodeWidth;
                fromY = fromCenterY;
            } else if (angleDeg >= 45 && angleDeg < 135) {
                // –í—ã—Ö–æ–¥ —Å–Ω–∏–∑—É
                fromX = fromCenterX;
                fromY = from.y + nodeHeight + 10;
            } else if (angleDeg >= -135 && angleDeg < -45) {
                // –í—ã—Ö–æ–¥ —Å–≤–µ—Ä—Ö—É
                fromX = fromCenterX;
                fromY = from.y - 10;
            } else {
                // –í—ã—Ö–æ–¥ —Å–ª–µ–≤–∞
                fromX = from.x - 10;
                fromY = fromCenterY;
            }
            
            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–æ—á–∫—É –≤—Ö–æ–¥–∞ –≤ —Ü–µ–ª–µ–≤—É—é –Ω–æ–¥—É (–ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω–∞—è —Å—Ç–æ—Ä–æ–Ω–∞)
            const reverseAngleDeg = (angleDeg + 180) % 360 - 180;
            
            if (reverseAngleDeg >= -45 && reverseAngleDeg < 45) {
                // –í—Ö–æ–¥ —Å–ø—Ä–∞–≤–∞
                toX = to.x + nodeWidth + 10;
                toY = toCenterY;
            } else if (reverseAngleDeg >= 45 && reverseAngleDeg < 135) {
                // –í—Ö–æ–¥ —Å–Ω–∏–∑—É
                toX = toCenterX;
                toY = to.y + nodeHeight + 10;
            } else if (reverseAngleDeg >= -135 && reverseAngleDeg < -45) {
                // –í—Ö–æ–¥ —Å–≤–µ—Ä—Ö—É
                toX = toCenterX;
                toY = to.y - 10;
            } else {
                // –í—Ö–æ–¥ —Å–ª–µ–≤–∞
                toX = to.x - 10;
                toY = toCenterY;
            }
            
            const deltaX = toX - fromX;
            const deltaY = toY - fromY;
            const length = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const lineAngle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
            
            line.style.left = fromX + 'px';
            line.style.top = fromY + 'px';
            line.style.width = length + 'px';
            line.style.transform = `rotate(${lineAngle}deg)`;
            
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –Ω–æ–¥ –¥–ª—è –ø–æ–∏—Å–∫–∞
            line.dataset.fromX = from.x;
            line.dataset.fromY = from.y;
            line.dataset.toX = to.x;
            line.dataset.toY = to.y;
            
            const arrow = document.createElement('div');
            arrow.className = 'arrow';
            line.appendChild(arrow);
            
            // –§—É–Ω–∫—Ü–∏—è –ø–æ–¥—Å–≤–µ—Ç–∫–∏ —Å–≤—è–∑–∞–Ω–Ω—ã—Ö –Ω–æ–¥
            const highlightNodes = () => {
                // –ù–∞—Ö–æ–¥–∏–º –Ω–æ–¥—ã –ø–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º
                const nodes = document.querySelectorAll('.node');
                nodes.forEach(node => {
                    const nodeX = parseInt(node.style.left);
                    const nodeY = parseInt(node.style.top);
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç —Å –Ω–∞—á–∞–ª–æ–º –∏–ª–∏ –∫–æ–Ω—Ü–æ–º —Å—Ç—Ä–µ–ª–∫–∏
                    if ((nodeX === from.x && nodeY === from.y) || (nodeX === to.x && nodeY === to.y)) {
                        node.classList.add('arrow-highlighted');
                    }
                });
            };
            
            // –§—É–Ω–∫—Ü–∏—è —Å–Ω—è—Ç–∏—è –ø–æ–¥—Å–≤–µ—Ç–∫–∏ –Ω–æ–¥
            const unhighlightNodes = () => {
                document.querySelectorAll('.node.arrow-highlighted').forEach(n => {
                    n.classList.remove('arrow-highlighted');
                });
            };
            
            // –ü—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏ –Ω–∞ —Å—Ç—Ä–µ–ª–∫—É - –ø–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º —Ç–æ–ª—å–∫–æ —Å—Ç—Ä–µ–ª–∫—É (–Ω–µ —Ç—Ä–æ–≥–∞–µ–º –Ω–æ–¥—ã –µ—Å–ª–∏ –æ–Ω–∏ locked)
            line.addEventListener('mouseenter', () => {
                if (!line.classList.contains('locked')) {
                    line.classList.add('highlighted');
                }
            });
            
            // –ü—Ä–∏ —É—Ö–æ–¥–µ –∫—É—Ä—Å–æ—Ä–∞ - —É–±–∏—Ä–∞–µ–º –ø–æ–¥—Å–≤–µ—Ç–∫—É —Ç–æ–ª—å–∫–æ —Å—Ç—Ä–µ–ª–∫–∏ (–Ω–æ–¥—ã –Ω–µ —Ç—Ä–æ–≥–∞–µ–º)
            line.addEventListener('mouseleave', () => {
                if (!line.classList.contains('locked')) {
                    line.classList.remove('highlighted');
                }
            });
            
            // –ü—Ä–∏ –∫–ª–∏–∫–µ - —Ñ–∏–∫—Å–∏—Ä—É–µ–º/—Å–Ω–∏–º–∞–µ–º –ø–æ–¥—Å–≤–µ—Ç–∫—É —Å—Ç—Ä–µ–ª–∫–∏ –∏ –Ω–æ–¥
            line.addEventListener('click', (e) => {
                e.stopPropagation();
                if (line.classList.contains('locked')) {
                    // –°–Ω–∏–º–∞–µ–º —Ñ–∏–∫—Å–∞—Ü–∏—é —Å —ç—Ç–æ–π —Å—Ç—Ä–µ–ª–∫–∏ –∏ –µ—ë –Ω–æ–¥
                    line.classList.remove('locked');
                    unhighlightNodes();
                } else {
                    // –£–±–∏—Ä–∞–µ–º locked —Å–æ –≤—Å–µ—Ö –¥—Ä—É–≥–∏—Ö —Å—Ç—Ä–µ–ª–æ–∫
                    document.querySelectorAll('.connection.locked').forEach(c => c.classList.remove('locked'));
                    // –£–±–∏—Ä–∞–µ–º –ø–æ–¥—Å–≤–µ—Ç–∫—É –í–°–ï–• –Ω–æ–¥ –ø–µ—Ä–µ–¥ –Ω–æ–≤–æ–π –ø–æ–¥—Å–≤–µ—Ç–∫–æ–π
                    unhighlightNodes();
                    // –§–∏–∫—Å–∏—Ä—É–µ–º —Ç–µ–∫—É—â—É—é —Å—Ç—Ä–µ–ª–∫—É
                    line.classList.add('locked');
                    line.classList.remove('highlighted');
                    // –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –Ω–æ–¥—ã —ç—Ç–æ–π —Å—Ç—Ä–µ–ª–∫–∏
                    highlightNodes();
                }
            });
            
            return line;
        }

        function updateTransform() {
            const canvas = document.getElementById('canvas');
            canvas.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
            document.getElementById('zoomLevel').textContent = Math.round(scale * 100) + '%';
        }

        function resetView() {
            scale = 0.12;
            translateX = 100;
            translateY = 100;
            updateTransform();
        }

        function centerView() {
            translateX = window.innerWidth / 2 - 800;
            translateY = 100;
            updateTransform();
        }

        const viewport = document.getElementById('viewport');

        viewport.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = viewport.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = Math.max(0.05, Math.min(2, scale * delta));
            const canvasX = (mouseX - translateX) / scale;
            const canvasY = (mouseY - translateY) / scale;
            scale = newScale;
            translateX = mouseX - canvasX * scale;
            translateY = mouseY - canvasY * scale;
            updateTransform();
        });

        viewport.addEventListener('mousedown', (e) => {
            if (e.button === 0) {
                isDragging = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                viewport.classList.add('dragging');
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                translateX += e.clientX - lastMouseX;
                translateY += e.clientY - lastMouseY;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                updateTransform();
            }
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
            viewport.classList.remove('dragging');
        });
    </script>
</body>
</html>
