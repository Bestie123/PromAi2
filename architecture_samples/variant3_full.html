<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Вариант 3: Полная диаграмма</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', sans-serif; background: #0d1117; color: #c9d1d9; overflow: hidden; }
        #canvas { width: 12000px; height: 8000px; position: relative; background: #0d1117; transform-origin: 0 0; }
        #viewport { width: 100vw; height: 100vh; overflow: hidden; position: relative; cursor: grab; }
        #viewport.dragging { cursor: grabbing; }
        
        .node {
            position: absolute; background: #21262d; border: 2px solid #30363d;
            border-radius: 12px; padding: 12px; min-width: 250px; max-width: 280px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4); transition: all 0.3s ease;
        }
        .node:hover { transform: scale(1.05); z-index: 100; }
        
        .phase-foundation { border-color: #f85149; box-shadow: 0 0 20px rgba(248, 81, 73, 0.3); }
        .phase-core { border-color: #f79009; box-shadow: 0 0 20px rgba(247, 144, 9, 0.3); }
        .phase-features { border-color: #3fb950; box-shadow: 0 0 20px rgba(63, 185, 80, 0.3); }
        .phase-polish { border-color: #a5a5a5; box-shadow: 0 0 20px rgba(165, 165, 165, 0.3); }
        .phase-other { border-color: #58a6ff; box-shadow: 0 0 20px rgba(88, 166, 255, 0.3); }
        
        .type-critical { background: linear-gradient(135deg, #21262d 0%, #2d1b1f 100%); }
        .type-important { background: linear-gradient(135deg, #21262d 0%, #2d2419 100%); }
        
        .node h3 { font-size: 13px; margin-bottom: 6px; color: #f0f6fc; }
        .phase-label { font-size: 9px; color: #8b949e; text-transform: uppercase; margin-bottom: 4px; }
        .criteria-label { font-size: 9px; color: #6e7681; }
        
        .dependency-line {
            position: absolute; height: 2px; transform-origin: left center; z-index: -1;
            background: #58a6ff;
            opacity: 0.4;
        }
        
        .blocking-line {
            position: absolute; height: 4px; transform-origin: left center; z-index: -1;
            background: #f85149;
            opacity: 0.8;
            box-shadow: 0 0 8px rgba(248, 81, 73, 0.5);
        }
        
        .hard-line {
            position: absolute; height: 3px; transform-origin: left center; z-index: -1;
            background: #f79009;
            opacity: 0.8;
            box-shadow: 0 0 6px rgba(247, 144, 9, 0.5);
        }
        
        .soft-line {
            position: absolute; height: 2px; transform-origin: left center; z-index: -1;
            background: #3fb950;
            opacity: 0.8;
            box-shadow: 0 0 4px rgba(63, 185, 80, 0.5);
        }
        
        .controls {
            position: fixed; top: 20px; left: 20px; z-index: 1000;
            background: rgba(33, 38, 45, 0.9); padding: 12px; border-radius: 8px;
        }
        .controls button {
            background: #238636; color: #fff; border: none; padding: 8px 12px;
            border-radius: 6px; margin-right: 8px; cursor: pointer; font-size: 12px;
        }
        .controls button:hover { background: #2ea043; }
        
        .legend {
            position: fixed; top: 20px; right: 20px; z-index: 1000;
            background: rgba(33, 38, 45, 0.9); padding: 12px; border-radius: 8px;
            font-size: 11px;
        }
        .legend-item { display: flex; align-items: center; margin-bottom: 6px; }
        .legend-box { width: 20px; height: 20px; border-radius: 4px; margin-right: 8px; }
        
        .stats {
            position: fixed; bottom: 20px; left: 20px; z-index: 1000;
            background: rgba(33, 38, 45, 0.9); padding: 8px 12px; border-radius: 6px;
            font-size: 12px; color: #3fb950;
        }
        
        .zoom-info {
            position: fixed; bottom: 20px; right: 20px; z-index: 1000;
            background: rgba(33, 38, 45, 0.9); padding: 8px 12px; border-radius: 6px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <button onclick="resetView()">Сброс</button>
        <button onclick="centerView()">Центр</button>
        <button onclick="toggleDeps()">Зависимости</button>
        <span style="color: #8b949e; margin-left: 12px;">Вариант 3: Автопозиционирование (полная)</span>
    </div>
    
    <div class="legend">
        <div style="font-weight: bold; margin-bottom: 8px;">Фазы:</div>
        <div class="legend-item">
            <div class="legend-box" style="background: #f85149;"></div>
            <span>Foundation</span>
        </div>
        <div class="legend-item">
            <div class="legend-box" style="background: #f79009;"></div>
            <span>Core</span>
        </div>
        <div class="legend-item">
            <div class="legend-box" style="background: #3fb950;"></div>
            <span>Features</span>
        </div>
        <div class="legend-item">
            <div class="legend-box" style="background: #a5a5a5;"></div>
            <span>Polish</span>
        </div>
    </div>
    
    <div class="stats">
        Узлов: <span id="nodeCount">0</span> | Зависимостей: <span id="depCount">0</span>
    </div>
    
    <div class="zoom-info">
        Зум: <span id="zoomLevel">100%</span>
    </div>
    
    <div id="viewport">
        <div id="canvas"></div>
    </div>

    <script>
        let scale = 0.2;
        let translateX = 100;
        let translateY = 50;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let showDeps = true;

        fetch('./variant3_full.json')
            .then(response => response.json())
            .then(data => {
                const positions = calculatePositions(data);
                renderDiagram(data, positions);
            });

        function calculatePositions(data) {
            const { columnWidth, rowHeight, startX, startY } = data.layout;
            const positions = {};
            const byCriteria = {};
            
            // Группируем по criteriaId
            Object.keys(data.nodes).forEach(id => {
                const criteriaId = data.nodes[id].criteriaId;
                if (!byCriteria[criteriaId]) byCriteria[criteriaId] = [];
                byCriteria[criteriaId].push(id);
            });
            
            // Позиционируем: колонка = criteriaId, строка = индекс в группе
            Object.keys(byCriteria).sort((a, b) => a - b).forEach((criteriaId, col) => {
                byCriteria[criteriaId].forEach((id, row) => {
                    positions[id] = {
                        x: startX + col * columnWidth,
                        y: startY + row * rowHeight
                    };
                });
            });
            
            return positions;
        }

        function renderDiagram(data, positions) {
            const canvas = document.getElementById('canvas');
            canvas.innerHTML = '';
            
            Object.keys(data.nodes).forEach(id => {
                const node = data.nodes[id];
                const pos = positions[id];
                
                const div = document.createElement('div');
                div.className = `node phase-${node.phase} type-${node.type}`;
                div.style.left = pos.x + 'px';
                div.style.top = pos.y + 'px';
                div.innerHTML = `
                    <div class="phase-label">${node.phase}</div>
                    <h3>${node.title || id}</h3>
                    <div class="criteria-label">Критерий ${node.criteriaId}</div>
                `;
                canvas.appendChild(div);
            });
            
            let depCount = 0;
            
            // Рендерим обычные зависимости (вопрос->ответ)
            Object.keys(data.dependencies).forEach(from => {
                data.dependencies[from].forEach(to => {
                    if (positions[from] && positions[to]) {
                        const line = createLine(positions[from], positions[to], 'normal');
                        canvas.appendChild(line);
                        depCount++;
                    }
                });
            });
            
            // Рендерим фазовые зависимости
            if (data.phaseDependencies) {
                ['blocking', 'hard', 'soft'].forEach(type => {
                    if (data.phaseDependencies[type]) {
                        data.phaseDependencies[type].forEach(dep => {
                            if (positions[dep.from] && positions[dep.to]) {
                                const line = createLine(positions[dep.from], positions[dep.to], type);
                                canvas.appendChild(line);
                                depCount++;
                            }
                        });
                    }
                });
            }
            
            document.getElementById('nodeCount').textContent = Object.keys(data.nodes).length;
            document.getElementById('depCount').textContent = depCount;
            updateTransform();
        }

        function createLine(from, to, type) {
            const line = document.createElement('div');
            const classes = {
                'normal': 'dependency-line',
                'blocking': 'blocking-line',
                'hard': 'hard-line',
                'soft': 'soft-line'
            };
            line.className = classes[type] || 'dependency-line';
            
            const dx = to.x - from.x;
            const dy = to.y - from.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;
            
            line.style.left = (from.x + 140) + 'px';
            line.style.top = (from.y + 40) + 'px';
            line.style.width = length + 'px';
            line.style.transform = `rotate(${angle}deg)`;
            
            return line;
        }

        function toggleDeps() {
            showDeps = !showDeps;
            document.querySelectorAll('.dependency-line').forEach(line => {
                line.style.display = showDeps ? 'block' : 'none';
            });
        }

        function updateTransform() {
            const canvas = document.getElementById('canvas');
            canvas.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
            document.getElementById('zoomLevel').textContent = Math.round(scale * 100) + '%';
        }

        function resetView() {
            scale = 0.2;
            translateX = 100;
            translateY = 50;
            updateTransform();
        }

        function centerView() {
            translateX = window.innerWidth / 2 - 500;
            translateY = 100;
            updateTransform();
        }

        const viewport = document.getElementById('viewport');

        viewport.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            scale = Math.max(0.1, Math.min(3, scale * delta));
            updateTransform();
        });

        viewport.addEventListener('mousedown', (e) => {
            if (e.button === 0) {
                isDragging = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                viewport.classList.add('dragging');
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                translateX += e.clientX - lastMouseX;
                translateY += e.clientY - lastMouseY;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                updateTransform();
            }
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
            viewport.classList.remove('dragging');
        });
    </script>
</body>
</html>